"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/math.ts
function clamp(n, min, max) {
  return Math.min(max, Math.max(min, n));
}
function sum(...args) {
  return flattenArrayable(args).reduce((a, b) => a + b, 0);
}

// src/array.ts
function toArray(array) {
  array = array || [];
  if (Array.isArray(array))
    return array;
  return [array];
}
function flattenArrayable(array) {
  return toArray(array).flat(1);
}
function mergeArrayable(...args) {
  return args.flatMap((i) => toArray(i));
}
function partition(array, filter) {
  const pass = [];
  const fail = [];
  array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));
  return [pass, fail];
}
function uniq(array) {
  return Array.from(new Set(array));
}
function last(array) {
  return at(array, -1);
}
function remove(array, value) {
  if (!array)
    return false;
  const index = array.indexOf(value);
  if (index >= 0) {
    array.splice(index, 1);
    return true;
  }
  return false;
}
function at(array, index) {
  const len = array.length;
  if (!len)
    return void 0;
  if (index < 0)
    index += len;
  return array[index];
}
function range(...args) {
  let start, stop, step;
  if (args.length === 1) {
    start = 0;
    step = 1;
    [stop] = args;
  } else {
    [start, stop, step = 1] = args;
  }
  const arr = [];
  let current = start;
  while (current < stop) {
    arr.push(current);
    current += step || 1;
  }
  return arr;
}
function move(arr, from, to) {
  arr.splice(to, 0, arr.splice(from, 1)[0]);
  return arr;
}
function clampArrayRange(n, arr) {
  return clamp(n, 0, arr.length - 1);
}

// src/base.ts
var assert = (condition, ...infos) => {
  if (!condition)
    throw new Error(...infos);
};
var toString2 = Object.prototype.toString;
var noop = () => {
};

// src/guards.ts
function notNullish(v) {
  return v != null;
}
function noNull(v) {
  return v !== null;
}
function notUndefined(v) {
  return v !== void 0;
}
function isTruthy(v) {
  return Boolean(v);
}

// src/is.ts
var isBrowser = typeof window !== "undefined";
var isDef = (val) => typeof val !== "undefined";
var isBoolean = (val) => typeof val === "boolean";
var isFunction = (val) => typeof val === "function";
var isNumber = (val) => typeof val === "number";
var isString = (val) => typeof val === "string";
var isObject = (val) => toString.call(val) === "[object Object]";
var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";

// src/string.ts
function slash(str) {
  return str.replace(/\\/g, "/");
}
function ensurePrefix(prefix, str) {
  if (!str.startsWith(prefix))
    return prefix + str;
  return str;
}

// src/time.ts
var timestamp = () => +Date.now();

// src/function.ts
function batchInvoke(functions) {
  functions.forEach((fn) => fn && fn());
}
function invoke(fn) {
  return fn();
}
function tap(value, callback) {
  callback(value);
  return value;
}

// src/object.ts
function objectMap(obj, fn) {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
}
function isKeyOf(obj, k) {
  return k in obj;
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function objectEntries(obj) {
  return Object.entries(obj);
}
function deepMerge(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (source === void 0)
    return target;
  if (isMergableObject(target) && isMergableObject(source)) {
    objectKeys(source).forEach((key) => {
      if (isMergableObject(source[key])) {
        if (!target[key])
          target[key] = {};
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    });
  }
  return deepMerge(target, ...sources);
}
function isMergableObject(item) {
  return isObject(item) && !Array.isArray(item);
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || !obj[k] === void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function clearUndefined(obj) {
  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
  return obj;
}

// src/promise.ts
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function sleep(ms, callback) {
  return new Promise((resolve) => setTimeout(async () => {
    await (callback == null ? void 0 : callback());
    resolve();
  }, ms));
}












































exports.assert = assert; exports.at = at; exports.batchInvoke = batchInvoke; exports.clamp = clamp; exports.clampArrayRange = clampArrayRange; exports.clearUndefined = clearUndefined; exports.createSingletonPromise = createSingletonPromise; exports.deepMerge = deepMerge; exports.ensurePrefix = ensurePrefix; exports.flattenArrayable = flattenArrayable; exports.invoke = invoke; exports.isBoolean = isBoolean; exports.isBrowser = isBrowser; exports.isDef = isDef; exports.isFunction = isFunction; exports.isKeyOf = isKeyOf; exports.isNumber = isNumber; exports.isObject = isObject; exports.isString = isString; exports.isTruthy = isTruthy; exports.isWindow = isWindow; exports.last = last; exports.mergeArrayable = mergeArrayable; exports.move = move; exports.noNull = noNull; exports.noop = noop; exports.notNullish = notNullish; exports.notUndefined = notUndefined; exports.objectEntries = objectEntries; exports.objectKeys = objectKeys; exports.objectMap = objectMap; exports.objectPick = objectPick; exports.partition = partition; exports.range = range; exports.remove = remove; exports.slash = slash; exports.sleep = sleep; exports.sum = sum; exports.tap = tap; exports.timestamp = timestamp; exports.toArray = toArray; exports.toString = toString2; exports.uniq = uniq;
