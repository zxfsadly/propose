"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



var _chunkAV6ARAKLjs = require('./chunk-AV6ARAKL.js');

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = _chunkAV6ARAKLjs.__commonJS.call(void 0, (exports, module) => {
  "use strict";
  module.exports = function equal2(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length; i-- !== 0; )
          if (!equal2(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal2(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node/common.ts
var _fs = require('fs');
var _path = require('path');
var _utils = require('@antfu/utils');

// node/utils.ts

function toAtFS(path) {
  return `/@fs${_utils.ensurePrefix.call(void 0, "/", _utils.slash.call(void 0, path))}`;
}

// node/common.ts
async function getIndexHtml({clientRoot, themeRoots, data, userRoot}) {
  var _a, _b;
  let main = await _fs.promises.readFile(_path.join.call(void 0, clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  const roots = _utils.uniq.call(void 0, [
    ...themeRoots,
    userRoot
  ]);
  for (const root of roots) {
    const path = _path.join.call(void 0, root, "index.html");
    if (!_fs.existsSync.call(void 0, path))
      continue;
    const index = await _fs.promises.readFile(path, "utf-8");
    head += `
${(((_a = index.match(/<head>([\s\S]*?)<\/head>/im)) == null ? void 0 : _a[1]) || "").trim()}`;
    body += `
${(((_b = index.match(/<body>([\s\S]*?)<\/body>/im)) == null ? void 0 : _b[1]) || "").trim()}`;
  }
  if (data.features.katex)
    head += '\n<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">';
  if (data.features.tweet)
    body += '\n<script src="https://platform.twitter.com/widgets.js"></script>';
  main = main.replace("__ENTRY__", toAtFS(_path.join.call(void 0, clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}

// node/plugins/windicss.ts

var _vitepluginwindicss = require('vite-plugin-windicss'); var _vitepluginwindicss2 = _interopRequireDefault(_vitepluginwindicss);
function createWindiCSSPlugin({themeRoots, clientRoot}, {windicss: windiOptions}) {
  return _vitepluginwindicss2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {
    configFiles: [
      ..._vitepluginwindicss.defaultConfigureFiles,
      ...themeRoots.map((i) => `${i}/windi.config.ts`),
      _path.resolve.call(void 0, clientRoot, "windi.config.ts")
    ]
  }, windiOptions), {
    hookOptions: {
      ignoreNodeModules: false
    }
  });
}

// node/plugins/preset.ts
var _pluginvue = require('@vitejs/plugin-vue'); var _pluginvue2 = _interopRequireDefault(_pluginvue);
var _vitepluginicons = require('vite-plugin-icons'); var _vitepluginicons2 = _interopRequireDefault(_vitepluginicons);
var _viteplugincomponents = require('vite-plugin-components'); var _viteplugincomponents2 = _interopRequireDefault(_viteplugincomponents);
var _vitepluginremoteassets = require('vite-plugin-remote-assets'); var _vitepluginremoteassets2 = _interopRequireDefault(_vitepluginremoteassets);


// node/plugins/config.ts
var _vite = require('vite');

// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.1.5",
  "@slidev/parser": "workspace:*",
  "@slidev/types": "workspace:*",
  "@vueuse/core": "^4.9.2",
  "@vueuse/head": "^0.5.1",
  codemirror: "^5.61.0",
  "file-saver": "^2.0.5",
  "js-base64": "^3.6.0",
  "js-yaml": "^4.1.0",
  "monaco-editor": "^0.23.0",
  prettier: "^2.2.1",
  recordrtc: "^5.6.2",
  vue: "^3.0.11",
  "vue-router": "^4.0.6",
  windicss: "^2.5.14"
};

// node/plugins/config.ts
var EXCLUDE = [
  "@slidev/types"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    config(config) {
      const injection = {
        resolve: {
          alias: {
            "@slidev/client/": `${toAtFS(options.clientRoot)}/`
          }
        },
        optimizeDeps: {
          include: [
            ...Object.keys(dependencies).filter((i) => !EXCLUDE.includes(i)),
            "codemirror/mode/javascript/javascript",
            "codemirror/mode/css/css",
            "codemirror/mode/markdown/markdown",
            "codemirror/mode/xml/xml",
            "codemirror/mode/htmlmixed/htmlmixed",
            "prettier/esm/parser-babel",
            "prettier/esm/parser-html",
            "prettier/esm/parser-typescript"
          ],
          exclude: [
            "vue-demi"
          ]
        }
      };
      if (options.data.features.monaco && (options.data.config.monaco === true || options.data.config.monaco === "build")) {
        injection.build = {
          rollupOptions: {
            output: {
              manualChunks: {
                jsonWorker: ["monaco-editor/esm/vs/language/json/json.worker"],
                cssWorker: ["monaco-editor/esm/vs/language/css/css.worker"],
                htmlWorker: ["monaco-editor/esm/vs/language/html/html.worker"],
                tsWorker: ["monaco-editor/esm/vs/language/typescript/ts.worker"],
                editorWorker: ["monaco-editor/esm/vs/editor/editor.worker"]
              }
            }
          }
        };
      }
      return _vite.mergeConfig.call(void 0, config, injection);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}

// node/plugins/loaders.ts
var import_fast_deep_equal = _chunkAV6ARAKLjs.__toModule.call(void 0, require_fast_deep_equal());


var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
var _markdownit = require('markdown-it'); var _markdownit2 = _interopRequireDefault(_markdownit);
var _markdownitlinkattributes = require('markdown-it-link-attributes'); var _markdownitlinkattributes2 = _interopRequireDefault(_markdownitlinkattributes);



var _fs3 = require('@slidev/parser/fs');
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json)$/;
function getBodyJson(req) {
  return new Promise((resolve5, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve5(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = _markdownit2.default.call(void 0, );
md.use(_markdownitlinkattributes2.default, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function prepareSlideInfo(data) {
  return _chunkAV6ARAKLjs.__objSpread.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, data), {
    notesHTML: md.render(data.note || "")
  });
}
function createSlidesLoader({data, entry, clientRoot, themeRoots, userRoot}, pluginOptions, VuePlugin, MarkdownPlugin) {
  const slidePrefix = "/@slidev/slides/";
  const hmrPages = new Set();
  const entryId = _utils.slash.call(void 0, entry);
  return [
    {
      name: "slidev:loader",
      configureServer(server) {
        server.watcher.add(entry);
        server.middlewares.use(async (req, res, next) => {
          var _a;
          const match = (_a = req.url) == null ? void 0 : _a.match(regexId);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = parseInt(no);
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(prepareSlideInfo(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            Object.assign(data.slides[idx], body);
            hmrPages.add(idx);
            server.ws.send({
              type: "custom",
              event: "slidev-update",
              data: {
                id: idx,
                data: prepareSlideInfo(data.slides[idx])
              }
            });
            await _fs3.save.call(void 0, data, entry);
            res.statusCode = 200;
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        var _a;
        if (ctx.file !== entryId)
          return;
        const newData = await _fs3.load.call(void 0, entry);
        const moduleIds = new Set();
        if (data.slides.length !== newData.slides.length)
          moduleIds.add("/@slidev/routes");
        if (!(0, import_fast_deep_equal.default)(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add("/@slidev/routes");
          _utils.range.call(void 0, data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.config, newData.config))
          moduleIds.add("/@slidev/configs");
        if (!(0, import_fast_deep_equal.default)(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.ws.send({type: "full-reload"});
          }, 1);
        }
        const length = Math.max(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          if (hmrPages.has(i))
            continue;
          const a = data.slides[i];
          const b = newData.slides[i];
          if ((a == null ? void 0 : a.content.trim()) === (b == null ? void 0 : b.content.trim()) && JSON.stringify(a.frontmatter) === JSON.stringify(b.frontmatter))
            continue;
          hmrPages.add(i);
        }
        (_a = pluginOptions.onDataReload) == null ? void 0 : _a.call(pluginOptions, newData, data);
        Object.assign(data, newData);
        const vueModules = (await Promise.all(Array.from(hmrPages).map(async (i) => {
          const file = `${slidePrefix}${i + 1}.md`;
          return await VuePlugin.handleHotUpdate(_chunkAV6ARAKLjs.__objSpread.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, ctx), {
            modules: Array.from(ctx.server.moduleGraph.getModulesByFile(file) || []),
            file,
            async read() {
              var _a2;
              return await transformMarkdown(MarkdownPlugin.transform((_a2 = newData.slides[i]) == null ? void 0 : _a2.content, file), i, newData);
            }
          }));
        }))).flatMap((i) => i || []);
        hmrPages.clear();
        const moduleEntries = Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id)).filter(_utils.notNullish).concat(vueModules).filter((i) => {
          var _a2;
          return !((_a2 = i.id) == null ? void 0 : _a2.startsWith("/@id/@vite-icons"));
        });
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(slidePrefix) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      load(id) {
        var _a;
        if (id === "/@slidev/routes")
          return generateRoutes();
        if (id === "/@slidev/layouts")
          return generateLayouts();
        if (id === "/@slidev/configs")
          return generateConfigs();
        if (id.startsWith(slidePrefix)) {
          const remaning = id.slice(slidePrefix.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = parseInt(no) - 1;
            if (type === "md")
              return (_a = data.slides[pageNo]) == null ? void 0 : _a.content;
          }
          return "";
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(slidePrefix))
          return;
        const remaning = id.slice(slidePrefix.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = parseInt(no) - 1;
        return transformMarkdown(code, pageNo, data);
      }
    }
  ];
  async function transformMarkdown(code, pageNo, data2) {
    var _a, _b;
    const layouts = await getLayouts();
    const frontmatter = _chunkAV6ARAKLjs.__objSpread.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, ((_a = data2.headmatter) == null ? void 0 : _a.defaults) || {}), ((_b = data2.slides[pageNo]) == null ? void 0 : _b.frontmatter) || {});
    const layoutName = (frontmatter == null ? void 0 : frontmatter.layout) || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName])
      throw new Error(`Unknown layout "${layoutName}"`);
    const imports = [
      `import InjectedLayout from "${toAtFS(layouts[layoutName])}"`,
      `const frontmatter = ${JSON.stringify(frontmatter)}`
    ];
    code = code.replace(/(<script setup.*>)/g, `$1${imports.join("\n")}
`);
    code = code.replace(/<template>([\s\S]*?)<\/template>/mg, '<template><InjectedLayout v-bind="frontmatter">$1</InjectedLayout></template>');
    return code;
  }
  async function getLayouts() {
    const layouts = {};
    const roots = [
      userRoot,
      ...themeRoots,
      clientRoot
    ];
    for (const root of roots) {
      const layoutPaths = await _fastglob2.default.call(void 0, "layouts/*.{vue,ts}", {
        cwd: root,
        absolute: true
      });
      for (const layoutPath of layoutPaths) {
        const layout = _path.basename.call(void 0, layoutPath).replace(/\.\w+$/, "");
        if (layouts[layout])
          continue;
        layouts[layout] = layoutPath;
      }
    }
    return layouts;
  }
  async function generateLayouts() {
    const imports = [];
    const layouts = _utils.objectMap.call(void 0, await getLayouts(), (k, v) => {
      imports.push(`import __layout_${k} from "${toAtFS(v)}"`);
      return [k, `__layout_${k}`];
    });
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
  async function generateRoutes() {
    const imports = [];
    const layouts = await getLayouts();
    imports.push(`import __layout__end from '${layouts.end}'`);
    let no = 1;
    const routes = [
      ...data.slides.map((i, idx) => {
        var _a;
        if ((_a = i.frontmatter) == null ? void 0 : _a.disabled)
          return void 0;
        imports.push(`import n${no} from '${slidePrefix}${idx + 1}.md'`);
        const additions = {
          slide: {
            start: i.start,
            end: i.end,
            note: i.note,
            file: entry,
            id: idx,
            no
          }
        };
        const meta = Object.assign({}, i.frontmatter, additions);
        const route = `{ path: '${no}', name: 'page-${no}', component: n${no}, meta: ${JSON.stringify(meta)} }`;
        no += 1;
        return route;
      }).filter(_utils.notNullish),
      `{ path: "${no}", component: __layout__end, meta: { layout: "end" } }`
    ];
    const routesStr = `export default [
${routes.join(",\n")}
]`;
    return [...imports, routesStr].join("\n");
  }
  function generateConfigs() {
    const config = _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, data.config);
    if (_utils.isString.call(void 0, config.info))
      config.info = md.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
}

// node/plugins/monaco.ts

function createMonacoTypesLoader() {
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    load(id) {
      const match = id.match(/^\/\@slidev-monaco-types\/(.*)$/);
      if (match) {
        const pkg = match[1];
        const info = _vite.resolvePackageData.call(void 0, pkg, process.cwd());
        if (!info)
          return;
        const typePath = info.data.types || info.data.typings;
        if (!typePath)
          return "";
        return [
          "import * as monaco from 'monaco-editor'",
          `import Type from "${info.dir}/${typePath}?raw"`,
          ...Object.keys(info.data.dependencies || {}).map((i) => `import "/@slidev-monaco-types/${i}"`),
          `monaco.languages.typescript.typescriptDefaults.addExtraLib(\`declare module "${pkg}" { \${Type} }\`)`
        ].join("\n");
      }
    }
  };
}

// node/plugins/entry.ts



function createEntryPlugin({clientRoot, themeRoots, userRoot}) {
  const mainEntry = _utils.slash.call(void 0, _path.resolve.call(void 0, clientRoot, "main.ts"));
  return {
    name: "slidev:entry",
    enforce: "pre",
    async transform(code, id) {
      if (id === mainEntry) {
        const imports = [];
        async function scanStyle(root) {
          const styles = [
            _path.join.call(void 0, root, "styles", "index.ts"),
            _path.join.call(void 0, root, "styles", "index.js"),
            _path.join.call(void 0, root, "styles", "index.css"),
            _path.join.call(void 0, root, "styles.css"),
            _path.join.call(void 0, root, "style.css")
          ];
          for (const style of styles) {
            if (_fs.existsSync.call(void 0, style)) {
              imports.push(`import "${toAtFS(style)}"`);
              return;
            }
          }
        }
        const roots = [
          ...themeRoots,
          userRoot
        ];
        for (const root of roots)
          await scanStyle(root);
        code = code.replace("/* __imports__ */", imports.join("\n"));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/setupClient.ts



function createClientSetupPlugin({clientRoot, themeRoots, userRoot}) {
  const setupEntry = _utils.slash.call(void 0, _path.resolve.call(void 0, clientRoot, "setup"));
  return {
    name: "slidev:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        const name = id.slice(setupEntry.length + 1);
        const imports = [];
        const injections = [];
        const asyncInjections = [];
        const setups = [
          ...themeRoots,
          userRoot
        ].map((i) => _path.join.call(void 0, i, "setup", name));
        setups.forEach((path, idx) => {
          if (!_fs.existsSync.call(void 0, path))
            return;
          imports.push(`import __n${idx} from '${toAtFS(path)}'`);
          injections.push(`// ${path}`, `__n${idx}()`);
          asyncInjections.push(`// ${path}`, `await __n${idx}(injection_arg)`);
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", injections.join("\n"));
        code = code.replace("/* __async_injections__ */", asyncInjections.join("\n"));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/server-ref.ts
var PREFIX = "/@server-ref/";
function VitePluginServerRef(options = {}) {
  const {
    dataMap = {},
    debounceMs = 10,
    debug = true
  } = options;
  return {
    name: "vite-plugin-server-ref",
    resolveId(id) {
      return id.startsWith(PREFIX) ? id : null;
    },
    configureServer(server) {
      server.middlewares.use(async (req, res, next) => {
        var _a, _b;
        if (!((_a = req.url) == null ? void 0 : _a.startsWith(PREFIX)) || req.method !== "POST")
          return next();
        const name = req.url.slice(PREFIX.length);
        const {data, timestamp} = await getBodyJson(req);
        const module = server.moduleGraph.getModuleById(PREFIX + name);
        if (module)
          server.moduleGraph.invalidateModule(module);
        dataMap[name] = data;
        server.ws.send({
          type: "custom",
          event: "server-ref",
          data: {
            name,
            data,
            timestamp
          }
        });
        (_b = options.onChanged) == null ? void 0 : _b.call(options, name, data, timestamp);
        res.write("");
        res.end();
      });
    },
    load(id) {
      var _a;
      if (!id.startsWith(PREFIX))
        return;
      const name = id.slice(PREFIX.length);
      return `
import { ref, watch } from "vue"

const data = ref(${JSON.stringify((_a = dataMap[name]) != null ? _a : null)})

if (import.meta.hot) {
  ${debug ? `console.log("[server-ref] [${name}] ref", data)` : ""}
  ${debug ? `console.log("[server-ref] [${name}] initial", data.value)` : ""}

  let skipNext = false
  let timer = null
  import.meta.hot.on("server-ref", (payload) =>{
    if (payload.name !== "${name}")
      return
    skipNext = true
    data.value = payload.data
    ${debug ? `console.log("[server-ref] [${name}] incoming", payload.data)` : ""}
  })
  watch(data, (v) => {
    if (skipNext) {
      skipNext = false
      return
    }
    if (timer)
      clearTimeout(timer)

    timer = setTimeout(()=>{
      ${debug ? `console.log("[server-ref] [${name}] outgoing", data.value)` : ""}
      fetch('${PREFIX + name}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          data: data.value,
          timestamp: Date.now(),
        })
      })
    }, ${debounceMs})
  }, { flush: 'sync', deep: true })
}

export default data
`;
    }
  };
}
var server_ref_default = VitePluginServerRef;

// node/plugins/markdown.ts
var _vitepluginmd = require('vite-plugin-md'); var _vitepluginmd2 = _interopRequireDefault(_vitepluginmd);

var _jsbase64 = require('js-base64'); var _jsbase642 = _interopRequireDefault(_jsbase64);

var _markdownitkatex = require('markdown-it-katex'); var _markdownitkatex2 = _interopRequireDefault(_markdownitkatex);

// node/plugins/setupNode.ts

var _fsextra = require('fs-extra');

var _jiti2 = require('jiti'); var _jiti3 = _interopRequireDefault(_jiti2);
var jiti = _jiti3.default.call(void 0, __filename);
async function loadSetups(roots, name, arg, initial, merge = true) {
  let returns = initial;
  for (const root of roots) {
    const path = _path.resolve.call(void 0, root, "setup", name);
    if (_fsextra.existsSync.call(void 0, path)) {
      const {default: setup} = jiti(path);
      const result = await setup(arg);
      if (result !== null) {
        returns = merge ? _utils.deepMerge.call(void 0, returns, result) : result;
      }
    }
  }
  return returns;
}

// node/plugins/markdown-it-prism.ts
var _prismjs = require('prismjs'); var _prismjs2 = _interopRequireDefault(_prismjs);
var _ = require('prismjs/components/'); var _2 = _interopRequireDefault(_);
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = _prismjs2.default.languages[lang];
  if (langObject === void 0) {
    _2.default.call(void 0, [lang]);
    langObject = _prismjs2.default.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    require(`prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  const code = text.trimEnd().split(/\r?\n/g).map((line) => prismLang ? _prismjs2.default.highlight(line, prismLang, langToUse) : markdownit.utils.escapeHtml(line)).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return `<pre${classAttribute}><code>${code}</code></pre>`;
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(_prismjs2.default);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/plugins/markdown-it-shiki.ts
function getThemeName(theme) {
  if (typeof theme === "string")
    return theme;
  return theme.name;
}
function resolveShikiOptions(options) {
  const themes = [];
  let darkModeThemes;
  if (!options.theme) {
    themes.push("nord");
  } else if (typeof options.theme === "string") {
    themes.push(options.theme);
  } else {
    if ("dark" in options.theme || "light" in options.theme) {
      darkModeThemes = options.theme;
      themes.push(options.theme.dark);
      themes.push(options.theme.light);
    } else {
      themes.push(options.theme);
    }
  }
  return _chunkAV6ARAKLjs.__objSpread.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, options), {
    themes,
    darkModeThemes: darkModeThemes ? {
      dark: getThemeName(darkModeThemes.dark),
      light: getThemeName(darkModeThemes.light)
    } : void 0
  });
}
var MarkdownItShiki = (markdownit, options = {}) => {
  const _highlighter = options.highlighter;
  const {darkModeThemes} = resolveShikiOptions(options);
  markdownit.options.highlight = (code, lang) => {
    if (darkModeThemes) {
      const dark = _highlighter.codeToHtml(code, lang || "text", darkModeThemes.dark).replace('<pre class="shiki"', '<pre class="slidev-code shiki shiki-dark"');
      const light = _highlighter.codeToHtml(code, lang || "text", darkModeThemes.light).replace('<pre class="shiki"', '<pre class="slidev-code shiki shiki-light"');
      return `<pre class="shiki-container">${dark}${light}</pre>`;
    } else {
      return _highlighter.codeToHtml(code, lang || "text").replace('<pre class="shiki"', '<pre class="slidev-code shiki"');
    }
  };
};
var markdown_it_shiki_default = MarkdownItShiki;

// node/plugins/markdown.ts
var DEFAULT_SHIKI_OPTIONS = {
  theme: {
    dark: "min-dark",
    light: "min-light"
  }
};
async function createMarkdownPlugin({data: {config}, roots, mode, entry}, {markdown: mdOptions}) {
  const setups = [];
  const entryPath = _utils.slash.call(void 0, entry);
  if (config.highlighter === "shiki") {
    const {getHighlighter} = await Promise.resolve().then(() => _chunkAV6ARAKLjs.__toModule.call(void 0, require("shiki")));
    const shikiOptions = await loadSetups(roots, "shiki.ts", {}, DEFAULT_SHIKI_OPTIONS, false);
    const {langs, themes} = resolveShikiOptions(shikiOptions);
    shikiOptions.highlighter = await getHighlighter({themes, langs});
    setups.push((md2) => md2.use(markdown_it_shiki_default, shikiOptions));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  return _vitepluginmd2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    markdownItOptions: {
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true
    },
    markdownItSetup(md2) {
      md2.use(_markdownitlinkattributes2.default, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(_markdownitkatex2.default);
      setups.forEach((i) => i(md2));
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monaco = config.monaco === true || config.monaco === mode ? transformMarkdownMonaco : truncateMancoMark;
        code = monaco(code);
        code = transformHighlighter(code);
        code = transformPageCSS(code, id);
        return code;
      }
    }
  }, mdOptions));
}
function transformMarkdownMonaco(md2) {
  const typeModules = new Set();
  md2 = md2.replace(/^```(\w+?)\s*{monaco([\w:,-]*)}[\s\n]*([\s\S]+?)^```/mg, (full, lang = "ts", options, code) => {
    options = options || "";
    lang = lang.trim();
    if (lang === "ts" || lang === "typescript") {
      Array.from(code.matchAll(/\s+from\s+(["'])([\/\w@-]+)\1/g)).map((i) => i[2]).filter(_utils.isTruthy).map((i) => typeModules.add(i));
    }
    const encoded = _jsbase642.default.encode(code, true);
    return `<Monaco :code="'${encoded}'" lang="${lang}" :readonly="${options.includes("readonly")}" />`;
  });
  if (typeModules.size)
    md2 += `
<script setup>
${Array.from(typeModules).map((i) => `import('/@slidev-monaco-types/${i}')`).join("\n")}
</script>
`;
  return md2;
}
function truncateMancoMark(code) {
  return code.replace(/{monaco.*?}/g, "");
}
function transformHighlighter(md2) {
  return md2.replace(/\n```(\w+?)\s*{([\d\w*,\|-]+)}[\s\n]*([\s\S]+?)\n```/mg, (full, lang = "", rangeStr, code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    return `
<CodeHighlightController :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}
${code}
\`\`\`

</CodeHighlightController>`;
  });
}
function transformPageCSS(md2, id) {
  var _a;
  const page = (_a = id.match(/(\d+)\.md$/)) == null ? void 0 : _a[1];
  if (!page)
    return md2;
  const result = md2.replace(/(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g, (full, start, css, end) => {
    if (!start.includes("scoped"))
      start = start.replace("<style", "<style scoped");
    return `${start}
.slidev-page-${page}{${css}}${end}`;
  });
  return result;
}

// node/plugins/fix.ts
function createFixPlugins({mode}) {
  const DEV = mode === "dev" ? "true" : "false";
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.endsWith(".vue"))
          return code.replace(/__DEV__/g, DEV);
      }
    },
    {
      name: "slidev:vue-escape",
      enforce: "post",
      transform(code, id) {
        if (id.endsWith(".md"))
          return code.replace(/\\{/g, "{");
      }
    }
  ];
}

// node/plugins/preset.ts
var customElements = new Set([
  "annotation",
  "math",
  "mrow",
  "mcol",
  "mfrac",
  "mi",
  "mn",
  "mo",
  "mover",
  "mspace",
  "mtable",
  "mtd",
  "msup",
  "msqrt",
  "mtr",
  "semantics"
]);
async function ViteSlidevPlugin(options, pluginOptions) {
  const {
    vue: vueOptions = {},
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    clientRoot,
    data: {config}
  } = options;
  const VuePlugin = _pluginvue2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: {
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      }
    }
  }, vueOptions));
  const MarkdownPlugin = await createMarkdownPlugin(options, pluginOptions);
  return [
    createWindiCSSPlugin(options, pluginOptions),
    MarkdownPlugin,
    VuePlugin,
    createSlidesLoader(options, pluginOptions, VuePlugin, MarkdownPlugin),
    _viteplugincomponents2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {
      extensions: ["vue", "md", "ts"],
      dirs: [
        `${clientRoot}/builtin`,
        `${clientRoot}/components`,
        ...themeRoots.map((i) => `${i}/components`),
        "src/components",
        "components"
      ],
      customLoaderMatcher: (id) => id.endsWith(".md"),
      customComponentResolvers: [
        _vitepluginicons.ViteIconsResolver.call(void 0, {
          componentPrefix: ""
        })
      ]
    }, componentsOptions)),
    _vitepluginicons2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {}, iconsOptions)),
    config.remoteAssets === true || config.remoteAssets === mode ? _vitepluginremoteassets2.default.call(void 0, _chunkAV6ARAKLjs.__objSpread.call(void 0, {
      rules: [
        ..._vitepluginremoteassets.DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build"
    }, remoteAssetsOptions)) : null,
    server_ref_default({
      dataMap: {
        sync: false,
        state: {
          page: 0,
          clicks: 0
        }
      }
    }),
    createConfigPlugin(options),
    createEntryPlugin(options),
    createClientSetupPlugin(options),
    createMonacoTypesLoader(),
    createFixPlugins(options)
  ].flat().filter(_utils.notNullish);
}





exports.getIndexHtml = getIndexHtml; exports.createWindiCSSPlugin = createWindiCSSPlugin; exports.ViteSlidevPlugin = ViteSlidevPlugin;
