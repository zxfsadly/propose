"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkYFLYAKONjs = require('./chunk-YFLYAKON.js');


var _chunkAV6ARAKLjs = require('./chunk-AV6ARAKL.js');

// node/export.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _pdflib = require('pdf-lib');
var _kolorist = require('kolorist');
var _cliprogress = require('cli-progress');
var _core = require('@slidev/parser/core');
function createSlidevProgress() {
  function getSpinner(n = 0) {
    return [_kolorist.cyan.call(void 0, "\u25CF"), _kolorist.green.call(void 0, "\u25C6"), _kolorist.blue.call(void 0, "\u25A0"), _kolorist.yellow.call(void 0, "\u25B2")][n % 4];
  }
  let current = 0;
  let spinner = 0;
  let timer;
  const progress = new (0, _cliprogress.SingleBar)({
    clearOnComplete: true,
    hideCursor: true,
    format: `  {spin} ${_kolorist.yellow.call(void 0, "rendering")} {bar} {value}/{total}`,
    linewrap: false,
    barsize: 30
  }, _cliprogress.Presets.shades_grey);
  return {
    bar: progress,
    start(total) {
      progress.start(total, 0, {spin: getSpinner(spinner)});
      timer = setInterval(() => {
        spinner += 1;
        progress.update(current, {spin: getSpinner(spinner)});
      }, 200);
    },
    update(v) {
      current = v;
      progress.update(v, {spin: getSpinner(spinner)});
    },
    stop() {
      clearInterval(timer);
      progress.stop();
    }
  };
}
async function exportSlides({
  port = 18724,
  total = 0,
  range,
  format = "pdf",
  output = "slides",
  base = "/",
  timeout = 500
}) {
  if (!_chunkYFLYAKONjs.packageExists.call(void 0, "playwright-chromium"))
    throw new Error("The exporting for Slidev is powered by Playwright, please installed it via `npm i playwright-chromium`");
  const {chromium} = await Promise.resolve().then(() => _chunkAV6ARAKLjs.__toModule.call(void 0, require("playwright-chromium")));
  const browser = await chromium.launch();
  const context = await browser.newContext({
    viewport: {
      width: 1920,
      height: 1080
    },
    deviceScaleFactor: 1
  });
  const page = await context.newPage();
  const progress = createSlidevProgress();
  async function go(no) {
    progress.update(no);
    await page.goto(`http://localhost:${port}${base}${no}?print`, {
      waitUntil: "networkidle"
    });
    await page.waitForTimeout(timeout);
    await page.waitForLoadState("networkidle");
    await page.emulateMedia({media: "screen"});
  }
  const pages = _core.parseRangeString.call(void 0, total, range);
  progress.start(pages.length);
  if (format === "pdf") {
    const buffers = [];
    for (const i of pages) {
      await go(i);
      const pdf = await page.pdf({
        width: 1920,
        height: 1080,
        margin: {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        },
        pageRanges: "1",
        printBackground: true,
        preferCSSPageSize: true
      });
      buffers.push(pdf);
    }
    const mergedPdf = await _pdflib.PDFDocument.create({});
    for (const pdfBytes of buffers) {
      const pdf = await _pdflib.PDFDocument.load(pdfBytes);
      const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
      copiedPages.forEach((page2) => {
        mergedPdf.addPage(page2);
      });
    }
    const buffer = await mergedPdf.save();
    if (!output.endsWith(".pdf"))
      output = `${output}.pdf`;
    await _fsextra2.default.writeFile(output, buffer);
  } else if (format === "png") {
    for (const i of pages) {
      await go(i);
      await page.screenshot({
        omitBackground: false,
        path: _path2.default.join(output, `${i.toString().padStart(2, "0")}.png`)
      });
    }
  } else {
    throw new Error(`Unsupported exporting format "${format}"`);
  }
  progress.stop();
  browser.close();
  return output;
}


exports.exportSlides = exportSlides;
