var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __objSpread = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// ../../node_modules/.pnpm/@antfu+utils@0.1.5/node_modules/@antfu/utils/dist/index.js
var require_dist = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function clamp(n, min, max) {
    return Math.min(max, Math.max(min, n));
  }
  function sum(...args) {
    return flattenArrayable(args).reduce((a, b) => a + b, 0);
  }
  function toArray(array) {
    array = array || [];
    if (Array.isArray(array))
      return array;
    return [array];
  }
  function flattenArrayable(array) {
    return toArray(array).flat(1);
  }
  function mergeArrayable(...args) {
    return args.flatMap((i) => toArray(i));
  }
  function partition(array, filter) {
    const pass = [];
    const fail = [];
    array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));
    return [pass, fail];
  }
  function uniq2(array) {
    return Array.from(new Set(array));
  }
  function last(array) {
    return at(array, -1);
  }
  function remove(array, value) {
    if (!array)
      return false;
    const index = array.indexOf(value);
    if (index >= 0) {
      array.splice(index, 1);
      return true;
    }
    return false;
  }
  function at(array, index) {
    const len = array.length;
    if (!len)
      return void 0;
    if (index < 0)
      index += len;
    return array[index];
  }
  function range2(...args) {
    let start, stop, step;
    if (args.length === 1) {
      start = 0;
      step = 1;
      [stop] = args;
    } else {
      [start, stop, step = 1] = args;
    }
    const arr = [];
    let current = start;
    while (current < stop) {
      arr.push(current);
      current += step || 1;
    }
    return arr;
  }
  function move(arr, from, to) {
    arr.splice(to, 0, arr.splice(from, 1)[0]);
    return arr;
  }
  function clampArrayRange(n, arr) {
    return clamp(n, 0, arr.length - 1);
  }
  var assert = (condition, ...infos) => {
    if (!condition)
      throw new Error(...infos);
  };
  var toString2 = Object.prototype.toString;
  var noop = () => {
  };
  function notNullish(v) {
    return v != null;
  }
  function noNull(v) {
    return v !== null;
  }
  function notUndefined(v) {
    return v !== void 0;
  }
  function isTruthy(v) {
    return Boolean(v);
  }
  var isBrowser = typeof window !== "undefined";
  var isDef = (val) => typeof val !== "undefined";
  var isBoolean = (val) => typeof val === "boolean";
  var isFunction = (val) => typeof val === "function";
  var isNumber = (val) => typeof val === "number";
  var isString = (val) => typeof val === "string";
  var isObject2 = (val) => toString.call(val) === "[object Object]";
  var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
  function slash(str) {
    return str.replace(/\\/g, "/");
  }
  function ensurePrefix(prefix, str) {
    if (!str.startsWith(prefix))
      return prefix + str;
    return str;
  }
  var timestamp = () => +Date.now();
  function batchInvoke(functions) {
    functions.forEach((fn) => fn && fn());
  }
  function invoke(fn) {
    return fn();
  }
  function objectMap(obj, fn) {
    return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
  }
  function isKeyOf(obj, k) {
    return k in obj;
  }
  function objectKeys(obj) {
    return Object.keys(obj);
  }
  function objectEntries(obj) {
    return Object.entries(obj);
  }
  function deepMerge(target, ...sources) {
    if (!sources.length)
      return target;
    const source = sources.shift();
    if (source === void 0)
      return target;
    if (isMergableObject(target) && isMergableObject(source)) {
      objectKeys(source).forEach((key) => {
        if (isMergableObject(source[key])) {
          if (!target[key])
            target[key] = {};
          deepMerge(target[key], source[key]);
        } else {
          target[key] = source[key];
        }
      });
    }
    return deepMerge(target, ...sources);
  }
  function isMergableObject(item) {
    return isObject2(item) && !Array.isArray(item);
  }
  function objectPick2(obj, keys, omitUndefined = false) {
    return keys.reduce((n, k) => {
      if (k in obj) {
        if (!omitUndefined || !obj[k] === void 0)
          n[k] = obj[k];
      }
      return n;
    }, {});
  }
  function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
      if (!_promise)
        _promise = fn();
      return _promise;
    }
    wrapper.reset = async () => {
      const _prev = _promise;
      _promise = void 0;
      if (_prev)
        await _prev;
    };
    return wrapper;
  }
  function sleep(ms, callback) {
    return new Promise((resolve) => setTimeout(async () => {
      await (callback == null ? void 0 : callback());
      resolve();
    }, ms));
  }
  exports.assert = assert;
  exports.at = at;
  exports.batchInvoke = batchInvoke;
  exports.clamp = clamp;
  exports.clampArrayRange = clampArrayRange;
  exports.createSingletonPromise = createSingletonPromise;
  exports.deepMerge = deepMerge;
  exports.ensurePrefix = ensurePrefix;
  exports.flattenArrayable = flattenArrayable;
  exports.invoke = invoke;
  exports.isBoolean = isBoolean;
  exports.isBrowser = isBrowser;
  exports.isDef = isDef;
  exports.isFunction = isFunction;
  exports.isKeyOf = isKeyOf;
  exports.isNumber = isNumber;
  exports.isObject = isObject2;
  exports.isString = isString;
  exports.isTruthy = isTruthy;
  exports.isWindow = isWindow;
  exports.last = last;
  exports.mergeArrayable = mergeArrayable;
  exports.move = move;
  exports.noNull = noNull;
  exports.noop = noop;
  exports.notNullish = notNullish;
  exports.notUndefined = notUndefined;
  exports.objectEntries = objectEntries;
  exports.objectKeys = objectKeys;
  exports.objectMap = objectMap;
  exports.objectPick = objectPick2;
  exports.partition = partition;
  exports.range = range2;
  exports.remove = remove;
  exports.slash = slash;
  exports.sleep = sleep;
  exports.sum = sum;
  exports.timestamp = timestamp;
  exports.toArray = toArray;
  exports.toString = toString2;
  exports.uniq = uniq2;
});

// src/core.ts
var import_utils = __toModule(require_dist());
import YAML from "js-yaml";
function stringify(data) {
  return `${data.slides.map(stringifySlide).join("\n").trim()}
`;
}
function filterDisabled(data) {
  data.slides = data.slides.filter((i) => {
    var _a;
    return !((_a = i.frontmatter) == null ? void 0 : _a.disabled);
  });
  return data;
}
function stringifySlide(data, idx = 1) {
  if (!data.raw)
    prettifySlide(data);
  return data.raw.startsWith("---") || idx === 0 ? data.raw : `---
${data.raw.startsWith("\n") ? data.raw : `
${data.raw}`}`;
}
function prettifySlide(data) {
  data.content = `
${data.content.trim()}
`;
  data.raw = Object.keys(data.frontmatter || {}).length ? `---
${YAML.dump(data.frontmatter).trim()}
---
${data.content}` : data.content;
  if (data.note)
    data.raw += `
<!--
${data.note.trim()}
-->
`;
  else
    data.raw += "\n";
  return data;
}
function prettify(data) {
  data.slides.forEach(prettifySlide);
  return data;
}
function matter(code) {
  let data = {};
  const content = code.replace(/^---([\s\S]*?)---/, (_, d) => {
    data = YAML.load(d);
    if (!(0, import_utils.isObject)(data))
      data = {};
    return "";
  });
  return {data, content};
}
function detectFeatures(code) {
  return {
    katex: !!code.match(/\$.*?\$/) || !!code.match(/$\$\$/),
    monaco: !!code.match(/{monaco.*}/),
    tweet: !!code.match(/<Tweet\b/)
  };
}
function parse(markdown, filepath) {
  var _a, _b;
  const lines = markdown.split(/\r?\n/g);
  const slides = [];
  function parseContent(raw) {
    var _a2, _b2;
    const result = matter(raw);
    let note;
    const frontmatter = result.data || {};
    const content = result.content.trim().replace(/<!--([\s\S]*)-->$/g, (_, v = "") => {
      note = v.trim();
      return "";
    });
    const title = frontmatter.title || frontmatter.name || ((_b2 = (_a2 = content.match(/^#+ (.*)$/m)) == null ? void 0 : _a2[1]) == null ? void 0 : _b2.trim());
    return {
      raw,
      title,
      content,
      frontmatter,
      note
    };
  }
  let start = 0;
  function slice(end) {
    if (start === end)
      return;
    const raw = lines.slice(start, end).join("\n");
    slides.push(__objSpread({
      index: slides.length,
      start,
      end
    }, parseContent(raw)));
    start = end + 1;
  }
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trimRight();
    if (line.match(/^---+$/)) {
      slice(i);
      const next = lines[i + 1];
      if (line.length === 3 && !(next == null ? void 0 : next.match(/^\s*$/))) {
        start = i;
        for (i += 1; i < lines.length; i++) {
          if (lines[i].trimRight().match(/^---$/))
            break;
        }
      }
    } else if (line.startsWith("```")) {
      for (i += 1; i < lines.length; i++) {
        if (lines[i].startsWith("```"))
          break;
      }
    }
  }
  if (start <= lines.length - 1)
    slice(lines.length);
  const headmatter = ((_a = slides[0]) == null ? void 0 : _a.frontmatter) || {};
  const defaultConfig = {
    theme: "default",
    title: ((_b = slides[0]) == null ? void 0 : _b.title) || "Slidev",
    remoteAssets: true,
    monaco: "dev",
    download: false,
    info: false,
    highlighter: "prism"
  };
  const config = Object.assign(defaultConfig, headmatter.config || {}, (0, import_utils.objectPick)(headmatter, Object.keys(defaultConfig)));
  return {
    raw: markdown,
    filepath,
    slides,
    config,
    features: detectFeatures(markdown),
    headmatter
  };
}
function parseRangeString(total, rangeStr) {
  if (!rangeStr || rangeStr === "all" || rangeStr === "*")
    return (0, import_utils.range)(1, total + 1);
  const pages = [];
  for (const part of rangeStr.split(/[,;]/g)) {
    if (!part.includes("-")) {
      pages.push(+part);
    } else {
      const [start, end] = part.split("-", 2);
      pages.push(...(0, import_utils.range)(+start, !end ? total + 1 : +end + 1));
    }
  }
  return (0, import_utils.uniq)(pages).filter((i) => i <= total).sort((a, b) => a - b);
}

export {
  stringify,
  filterDisabled,
  stringifySlide,
  prettifySlide,
  prettify,
  detectFeatures,
  parse,
  parseRangeString
};
