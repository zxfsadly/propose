var __defProp = Object.defineProperty;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __assign = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/context.ts
import {relative} from "path";
import Debug3 from "debug";
import chokidar from "chokidar";

// src/utils.ts
import {join as join2, parse, resolve} from "path";
import minimatch from "minimatch";

// src/helpers/libraryResolver.ts
import fs from "fs";
import {dirname, join} from "path";
import Debug from "debug";
var debug = Debug("vite-plugin-components:helper:library");
function tryLoadVeturTags(name) {
  var _a;
  try {
    const pkgPath = require.resolve(`${name}/package.json`);
    if (!pkgPath)
      return;
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
    const tagsPath = (_a = pkg == null ? void 0 : pkg.vetur) == null ? void 0 : _a.tags;
    if (!tagsPath)
      return;
    const tags = JSON.parse(fs.readFileSync(join(dirname(pkgPath), tagsPath), "utf-8"));
    return Object.keys(tags).map((i) => camelCase(i));
  } catch (e) {
    console.error(e);
  }
}
function LibraryResolver(options) {
  const {
    name: libraryName,
    entries = tryLoadVeturTags(options.name),
    prefix = ""
  } = options;
  if (!entries) {
    console.warn(`[vite-plugin-components] Failed to load Vetur tags from library "${libraryName}"`);
    return () => {
    };
  }
  debug(entries);
  const prefixKebab = kebabCase(prefix);
  const kebabEntries = entries.map((name) => ({name, kebab: kebabCase(name)}));
  return (name) => {
    const kebab = kebabCase(name);
    let componentName = kebab;
    if (prefixKebab) {
      if (!kebab.startsWith(`${prefixKebab}-`))
        return;
      componentName = kebab.slice(prefixKebab.length + 1);
    }
    for (const entry of kebabEntries) {
      if (entry.kebab === componentName)
        return {path: libraryName, importName: entry.name};
    }
  };
}

// src/constants.ts
var defaultOptions = {
  dirs: "src/components",
  extensions: "vue",
  transformer: "vue3",
  deep: true,
  directoryAsNamespace: false,
  globalNamespaces: [],
  libraries: [],
  customLoaderMatcher: () => false,
  customComponentResolvers: [],
  importPathTransform: (v) => v
};

// src/utils.ts
function slash(str) {
  return str.replace(/\\/g, "/");
}
function pascalCase(str) {
  return capitalize(camelCase(str));
}
function camelCase(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function toArray(arr) {
  if (Array.isArray(arr))
    return arr;
  return [arr];
}
function parseId(id) {
  const index = id.indexOf("?");
  if (index < 0) {
    return {path: id, query: {}};
  } else {
    const query = Object.fromEntries(new URLSearchParams(id.slice(index)));
    return {
      path: id.slice(0, index),
      query
    };
  }
}
function isEmpty(value) {
  if (!value || value === null || value === void 0 || Array.isArray(value) && Object.keys(value).length <= 0)
    return true;
  else
    return false;
}
function matchGlobs(filepath, globs) {
  for (const glob of globs) {
    if (minimatch(slash(filepath), glob))
      return true;
  }
  return false;
}
function stringifyImport(info) {
  if (typeof info === "string")
    return `import '${info}'`;
  if (!info.name)
    return `import '${info.path}'`;
  else if (info.importName)
    return `import { ${info.importName} as ${info.name} } from '${info.path}'`;
  else
    return `import ${info.name} from '${info.path}'`;
}
function stringifyComponentImport({name, path, importName, sideEffects}, ctx) {
  if (ctx.options.importPathTransform) {
    const result = ctx.options.importPathTransform(path);
    if (result != null)
      path = result;
  }
  const imports = [
    stringifyImport({name, path, importName})
  ];
  if (sideEffects)
    toArray(sideEffects).forEach((i) => imports.push(stringifyImport(i)));
  return imports.join("\n");
}
function resolveOptions(options, viteConfig) {
  const resolved = Object.assign({}, defaultOptions, options);
  resolved.libraries = toArray(resolved.libraries).map((i) => typeof i === "string" ? {name: i} : i);
  resolved.customComponentResolvers = toArray(resolved.customComponentResolvers);
  resolved.customComponentResolvers.push(...resolved.libraries.map((lib) => LibraryResolver(lib)));
  resolved.extensions = toArray(resolved.extensions);
  const extsGlob = resolved.extensions.length === 1 ? resolved.extensions : `{${resolved.extensions.join(",")}}`;
  resolved.dirs = toArray(resolved.dirs);
  resolved.resolvedDirs = resolved.dirs.map((i) => slash(resolve(viteConfig.root, i)));
  resolved.globs = resolved.dirs.map((i) => resolved.deep ? slash(join2(i, `**/*.${extsGlob}`)) : slash(join2(i, `*.${extsGlob}`)));
  if (!resolved.extensions.length)
    throw new Error("[vite-plugin-components] extensions are required to search for components");
  return resolved;
}
function getNameFromFilePath(filePath, options) {
  const {resolvedDirs, directoryAsNamespace, globalNamespaces} = options;
  const parsedFilePath = parse(slash(filePath));
  let strippedPath = "";
  for (const dir of resolvedDirs) {
    if (parsedFilePath.dir.startsWith(dir)) {
      strippedPath = parsedFilePath.dir.slice(dir.length);
      break;
    }
  }
  let folders = strippedPath.slice(1).split("/").filter(Boolean);
  let filename = parsedFilePath.name;
  if (filename === "index" && !directoryAsNamespace) {
    filename = `${folders.slice(-1)[0]}`;
    return filename;
  }
  if (directoryAsNamespace) {
    if (globalNamespaces.some((name) => folders.includes(name)))
      folders = folders.filter((f) => !globalNamespaces.includes(f));
    if (filename.toLowerCase() === "index")
      filename = "";
    if (!isEmpty(folders)) {
      filename = [...folders, filename].filter(Boolean).join("-");
    }
    return filename;
  }
  return filename;
}
function resolveAlias(filepath, alias = []) {
  const result = filepath;
  if (Array.isArray(alias)) {
    for (const {find, replacement} of alias)
      result.replace(find, replacement);
  }
  return result;
}

// src/fs/glob.ts
import fg from "fast-glob";
import Debug2 from "debug";
var debug2 = Debug2("vite-plugin-components:glob");
function searchComponents(ctx) {
  var _a;
  debug2(`started with: [${ctx.options.globs.join(", ")}]`);
  const root = ctx.root;
  const files = fg.sync(ctx.options.globs, {
    ignore: ["node_modules"],
    onlyFiles: true,
    cwd: root,
    absolute: true
  });
  if (!files.length && !((_a = ctx.options.customComponentResolvers) == null ? void 0 : _a.length))
    console.warn("[vite-plugin-components] no components found");
  debug2(`${files.length} components found.`);
  ctx.addComponents(files);
}

// src/context.ts
var debug3 = {
  components: Debug3("vite-plugin-components:context:components"),
  search: Debug3("vite-plugin-components:context:search"),
  hmr: Debug3("vite-plugin-components:context:hmr")
};
var Context = class {
  constructor(options, viteConfig) {
    this.viteConfig = viteConfig;
    this._componentPaths = new Set();
    this._componentNameMap = {};
    this._componentUsageMap = {};
    this._searched = false;
    this.options = resolveOptions(options, viteConfig);
    const {globs, dirs} = this.options;
    if (viteConfig.command === "serve") {
      chokidar.watch(dirs, {ignoreInitial: true, cwd: this.root}).on("unlink", (path) => {
        if (matchGlobs(path, globs)) {
          this.removeComponents(path);
          this.onUpdate(path);
        }
      }).on("add", (path) => {
        if (matchGlobs(path, globs)) {
          this.addComponents(path);
          this.onUpdate(path);
        }
      });
    }
  }
  get root() {
    return this.viteConfig.root;
  }
  setServer(server) {
    this._server = server;
  }
  updateUsageMap(path, paths) {
    if (!this._componentUsageMap[path])
      this._componentUsageMap[path] = new Set();
    paths.forEach((p) => {
      this._componentUsageMap[path].add(p);
    });
  }
  addComponents(paths) {
    debug3.components("add", paths);
    const size = this._componentPaths.size;
    toArray(paths).forEach((p) => this._componentPaths.add(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  removeComponents(paths) {
    debug3.components("remove", paths);
    const size = this._componentPaths.size;
    toArray(paths).forEach((p) => this._componentPaths.delete(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  onUpdate(path) {
    if (!this._server)
      return;
    const payload = {
      type: "update",
      updates: []
    };
    const timestamp = +new Date();
    const name = pascalCase(getNameFromFilePath(path, this.options));
    Object.entries(this._componentUsageMap).forEach(([key, values]) => {
      if (values.has(name)) {
        const r = `/${slash(relative(this.viteConfig.root, key))}`;
        payload.updates.push({
          acceptedPath: r,
          path: r,
          timestamp,
          type: "js-update"
        });
      }
    });
    if (payload.updates.length)
      this._server.ws.send(payload);
  }
  updateComponentNameMap() {
    this._componentNameMap = {};
    Array.from(this._componentPaths).forEach((path) => {
      const name = pascalCase(getNameFromFilePath(path, this.options));
      if (this._componentNameMap[name]) {
        console.warn(`[vite-plugin-components] component "${name}"(${path}) has naming conflicts with other components, ignored.`);
        return;
      }
      this._componentNameMap[name] = {
        name,
        path: `/${this.relative(path)}`
      };
    });
  }
  findComponent(name, excludePaths = []) {
    const info = this._componentNameMap[name];
    if (info && !excludePaths.includes(info.path) && !excludePaths.includes(info.path.slice(1)))
      return info;
    for (const resolver of this.options.customComponentResolvers) {
      const result = resolver(name);
      if (result) {
        if (typeof result === "string") {
          return {
            name,
            path: result
          };
        } else {
          return __assign({
            name
          }, result);
        }
      }
    }
    return void 0;
  }
  findComponents(names, excludePaths = []) {
    return names.map((name) => this.findComponent(name, excludePaths)).filter(Boolean);
  }
  normalizePath(path) {
    var _a, _b, _c;
    return resolveAlias(path, ((_b = (_a = this.viteConfig) == null ? void 0 : _a.resolve) == null ? void 0 : _b.alias) || ((_c = this.viteConfig) == null ? void 0 : _c.alias) || []);
  }
  relative(path) {
    if (path.startsWith("/") && !path.startsWith(this.root))
      return slash(path.slice(1));
    return slash(relative(this.root, path));
  }
  searchGlob() {
    if (this._searched)
      return;
    searchComponents(this);
    debug3.search(this._componentNameMap);
    this._searched = true;
  }
  get componentNameMap() {
    return this._componentNameMap;
  }
};

// src/transforms/vue3.ts
import Debug4 from "debug";
var debug4 = Debug4("vite-plugin-components:transform:vue3");
function Vue3Transformer(ctx) {
  return (code, id, path, query) => {
    if (!(path.endsWith(".vue") || ctx.options.customLoaderMatcher(id)))
      return code;
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug4(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    let transformed = code.replace(/_resolveComponent\("(.+?)"\)/g, (str, match) => {
      if (match && !match.startsWith("_")) {
        debug4(`| ${match}`);
        const name = pascalCase(match);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath]);
        if (component) {
          const var_name = `__vite_components_${no}`;
          head.push(stringifyComponentImport(__assign(__assign({}, component), {name: var_name}), ctx));
          no += 1;
          return var_name;
        }
      }
      return str;
    });
    debug4(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    transformed = `${head.join("\n")}
${transformed}`;
    return transformed;
  };
}

// src/transforms/vue2.ts
import Debug5 from "debug";
var debug5 = Debug5("vite-plugin-components:transform:vue2");
function Vue2Transformer(ctx) {
  return (code, id, path, query) => {
    if (!(path.endsWith(".vue") || ctx.options.customLoaderMatcher(id)))
      return code;
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug5(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    let transformed = code.replace(/_c\(['"](.+?)["']([,)])/g, (str, match, append) => {
      if (match && !match.startsWith("_")) {
        debug5(`| ${match}`);
        const name = pascalCase(match);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath]);
        if (component) {
          const var_name = `__vite_components_${no}`;
          head.push(stringifyComponentImport(__assign(__assign({}, component), {name: var_name}), ctx));
          no += 1;
          return `_c(${var_name}${append}`;
        }
      }
      return str;
    });
    debug5(transformed);
    debug5(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    transformed = `${head.join("\n")}
${transformed}`;
    return transformed;
  };
}

// src/resolvers/antdv.ts
var AntDesignVueResolver = () => (name) => {
  if (name.match(/^A[A-Z]/))
    return {importName: name.slice(1), path: "ant-design-vue/es"};
};

// src/resolvers/element-plus.ts
var ElementPlusResolver = (options = {}) => (name) => {
  const {importStyle = true} = options;
  if (name.startsWith("El")) {
    const partialName = name[2].toLowerCase() + name.substring(3).replace(/[A-Z]/g, (l) => `-${l.toLowerCase()}`);
    return {
      path: `element-plus/es/el-${partialName}`,
      sideEffects: importStyle ? `element-plus/packages/theme-chalk/src/${partialName}.scss` : void 0
    };
  }
};

// src/resolvers/vant.ts
var VantResolver = (options = {}) => (name) => {
  const {importStyle = true} = options;
  if (name.startsWith("Van")) {
    const partialName = name.slice(3);
    return {
      importName: partialName,
      path: "vant/es",
      sideEffects: importStyle ? `vant/es/${kebabCase(partialName)}/style` : void 0
    };
  }
};

// src/resolvers/vuetify.ts
var VuetifyResolver = () => (name) => {
  if (name.match(/^V[A-Z]/))
    return {importName: name, path: "vuetify/lib"};
};

// src/index.ts
function VitePluginComponents(options = {}) {
  let ctx;
  let transformers;
  return {
    name: "vite-plugin-components",
    enforce: "post",
    configResolved(config) {
      if (config.plugins.find((i) => i.name === "vite-plugin-vue2"))
        options.transformer = options.transformer || "vue2";
      ctx = new Context(options, config);
      transformers = [
        ctx.options.transformer === "vue2" ? Vue2Transformer(ctx) : Vue3Transformer(ctx)
      ];
    },
    configureServer(server) {
      ctx.setServer(server);
    },
    transform(code, id) {
      const {path, query} = parseId(id);
      for (const trans of transformers)
        code = trans(code, id, path, query);
      return code;
    }
  };
}
var src_default = VitePluginComponents;
export {
  AntDesignVueResolver,
  ElementPlusResolver,
  LibraryResolver,
  VantResolver,
  VuetifyResolver,
  camelCase,
  src_default as default,
  kebabCase,
  pascalCase,
  tryLoadVeturTags
};
