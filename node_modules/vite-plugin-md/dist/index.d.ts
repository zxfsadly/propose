import { UserConfig, Plugin } from 'vite';
import MarkdownIt from 'markdown-it';
import { FilterPattern } from '@rollup/pluginutils';

declare enum PipelineStage {
    /**
     * Initialized with incoming filename, config, options,
     * available events (core and provided by builders).
     */
    initialize = "initialize",
    /**
     * All frontmatter has been extracted from default values and page values
     * but no mapping has been done yet.
     *
     * Note: this is the event hook which the included `meta` builder connects
     * to and it in turn _provides_ a `metaMapped` hook.
     */
    metaExtracted = "metaExtracted",
    /**
     * The **MarkdownIt** parser is initialized, all builders
     * connecting at this point will receive a valid `md` parser
     * object so that they can participate in MD-to-HTML parsing.
     */
    parser = "parser",
    /**
     * The **MarkdownIt** parser is initialized and all builders
     * have been able to apply their customizations to it.
     */
    parsed = "parsed",
    /**
     * SFC blocks (template, script, and an array of customBlocks) are ready for
     * builders to inspect/mutate/etc.
     */
    sfcBlocksExtracted = "sfcBlocksExtracted",
    /**
     * All mutations of page are complete; builders can hook into this stage but
     * will _not_ be able to mutate at this stage.
     */
    closeout = "closeout"
}
declare type IPipelineStage = EnumValues<PipelineStage>;
interface RulesUse {
    ruleName: string;
    usage: 'adds' | 'patches' | 'modifies';
    description?: string;
}
interface BuilderRegistration<O extends BuilderOptions, H extends IPipelineStage> {
    name: string;
    description?: string;
    /** The lifecycle event/hook which this builder will respond to */
    lifecycle: H;
    /**
     * The builder's handler function which receives the _payload_ for the
     * event lifecycle hook configured and then is allowed to mutate these
     * properties and pass back a similarly structured object to continue
     * on in that pipeline stage.
     */
    handler: BuilderHandler<O, H>;
    /**
     * The options _specific_ to the builder
     */
    options: O;
    /**
     * This isn't strictly required, but it is nice to express which rules you have used
     * modified, or added from the MarkdownIt parser.
     *
     * Note: builders should try to avoid mutating core rules; if they need a modification
     * for their purposes consider _monkey patching_ the rule so that downstream rules
     * have a better understanding of current rule state.
     */
    parserRules?: RulesUse[];
    /**
     * If this plugin needs to modify the configuration in some way at initialization
     * it can add a function here to do that. In most cases, the builder can simply
     * wait for their event hook to be called (at which point they will get the configuration
     * passed to them).
     */
    initializer?: BuilderHandler<O, PipelineStage.initialize>;
}
interface PipelineProperties {
    fileName: string;
    /** the raw content in the file being processed */
    content: string;
    /** the `vite-plugin-md` options */
    options: ResolvedOptions;
    /** the Vite config */
    viteConfig: UserConfig;
    /** the frontmatter metadata */
    frontmatter: Frontmatter;
    /**
     * Meta properties that will be put into the HEAD section
     */
    meta: MetaProperty[];
    /**
     * Meta properties which are to be added to the VueJS router's "meta" attribute
     * for this page's route
     */
    routeMeta: Record<string, any>;
    /**
     * Non-meta tags that will be put into the HEAD section of the page
     */
    head: Record<string, any>;
    excerpt?: string;
    /**
     * The markdown content (after extracting frontmatter)
     */
    md: string;
    /** the **MarkdownIT** parser instance */
    parser: MarkdownIt;
    /**
     * the HTML produced from MD content (and using parser rules passed in)
     */
    html: string;
    /**
     * If any code blocks were found on the page then their languages will be represented
     * here.
     */
    fencedLanguages: Set<string>;
    /**
     * all hoisted scripts
     */
    hoistedScripts: string[];
    /** the SFC's template block (aka, html content) */
    templateBlock: string;
    /** the `<script [setup] ...>` block */
    scriptBlock: string;
    /** any other top-level SFC blocks besides "template" and "script" */
    customBlocks: string[];
    /** the finalized component in string form */
    component: string;
}
declare type InitializedOmissions = 'md' | 'fencedLanguages' | 'frontmatter' | 'head' | 'meta' | 'routeMeta' | 'excerpt' | 'html' | 'hoistedScripts' | 'templateBlock' | 'parser' | 'scriptBlock' | 'customBlocks' | 'component';
/** after extracting metadata */
declare type MetaOmissions = 'fencedLanguages' | 'parser' | 'html' | 'hoistedScripts' | 'templateBlock' | 'scriptBlock' | 'customBlocks' | 'component';
/** after providing the markdown-it parser */
declare type ParserOmissions = 'fencedLanguages' | 'html' | 'hoistedScripts' | 'templateBlock' | 'scriptBlock' | 'customBlocks' | 'component';
/** after parsing to raw HTML using markdown-it */
declare type ParsedOmissions = 'hoistedScripts' | 'templateBlock' | 'scriptBlock' | 'customBlocks' | 'component';
declare type SfcBlockOmissions = 'component';
declare type PipelineAvail<S extends IPipelineStage> = S extends 'initialize' ? Omit<PipelineProperties, InitializedOmissions> : S extends 'metaExtracted' ? Omit<PipelineProperties, MetaOmissions> : S extends 'parser' ? Omit<PipelineProperties, ParserOmissions> : S extends 'parsed' ? Omit<PipelineProperties, ParsedOmissions> : S extends 'sfcBlocksExtracted' ? Omit<PipelineProperties, SfcBlockOmissions> : S extends 'closeout' ? PipelineProperties : never;
/**
 * The _state/payload_ that is available at a given stage in the pipeline process.
 *
 * - `<S>` provides the stage we're in
 * - `<E>` allows a builder to provide additional props for an event they are providing
 */
declare type Pipeline<S extends IPipelineStage, E extends {} = {}> = PipelineAvail<S> & E;
/**
 * The Builder's event listener/handler
 */
declare type BuilderHandler<O extends BuilderOptions, S extends IPipelineStage, R extends Pipeline<S> = Pipeline<S>> = (payload: Pipeline<S>, options: O) => R;
/**
 * Builder's must provide an export which meets this API constraint. Basic
 * structure of this higher order function is:
 *
 * - options( ) -> register( ) -> { handler( payload ) -> payload }
 */
declare type BuilderApi<O extends {}, S extends IPipelineStage> = (options?: O) => () => BuilderRegistration<O, S>;
/**
 * Builder options are expected to be a key/value dictionary but must
 * be allowed to be an empty object
 * */
declare type BuilderOptions = Record<string, any> | {};

/**
 * The key/value definition for Route Properties.
 *
 * Note: we know that "layout" is likely and a _string_
 * but all other props are possible.
 */
interface RouteProperties {
    layout?: string;
    [key: string]: unknown;
}
/** a `<meta />` property in HTML is defined with the following name/values */
interface MetaProperty {
    key?: string;
    /**
     * the "name" property used by Facebook and other providers who
     * use the Opengraph standards
     */
    property?: string;
    /**
     * used by google to identify the "name" of the name/value pair
     */
    itemprop?: string;
    /**
     * used by Twitter to indicate the "name" field in a meta properties
     * name/value pairing
     */
    name?: string;
    /**
     * The value of the meta property
     */
    content?: any;
    [key: string]: unknown;
}
interface LinkElement {
    href?: string | undefined;
    tagName?: string | undefined;
    class?: string | undefined;
    ref?: string | undefined;
    target?: string | undefined;
    to?: string | undefined;
    [key: string]: unknown;
}
/**
 * Frontmatter content is represented as key/value dictionary
 */
interface Frontmatter {
    title?: string;
    description?: string;
    subject?: string;
    category?: string;
    name?: string;
    excerpt?: string;
    image?: string;
    meta?: MetaProperty[];
    [key: string]: unknown;
}
declare type EnumValues<T extends string | number> = `${T}`;
/**
 * A function which receives the full content of the page and
 * gives control to the function to determine what part should
 * be considered the excerpt.
 *
 * Example:
 * ```ts
 * function firstFourLines(file, options) {
 *    file.excerpt = file.content
 *      .split('\n')
 *      .slice(0, 4)
 *      .join(' ')
 * }
 * ```
 */
declare type ExcerptFunction = (contents: string, options: GraymatterOptions) => string;
/**
 * Options for Graymatter parser [[Docs](https://github.com/jonschlinkert/gray-matter#options)]
 */
interface GraymatterOptions {
    /**
     * Extract an excerpt that directly follows front-matter, or is the
     * first thing in the string if no front-matter exists.
     *
     * If set to excerpt `true`, it will look for the frontmatter delimiter,
     * --- by default and grab everything leading up to it.
     *
     * You can also set excerpt to a function. This function that receives the
     * full page contents and Graymatter Options as parameters and lets you
     * decide what should be included.
     *
     * @default undefined
     *
     * @deprecated use the root option of `excerpt` instead
     */
    excerpt?: boolean | ExcerptFunction;
    /**
     * Define a custom separator to use for excerpts.
     *
     * This will be used only when the `excerpt` property is set
     * to `true`.
     *
     * @default undefined
     *
     * @deprecated use a string value in the root `excerpt` option instead
     */
    excerpt_separator?: string;
    /**
     * Define custom engines for parsing and/or stringifying front-matter.
     *
     * Engines may either be an object with `parse` and (optionally) stringify
     * methods, or a function that will be used for parsing only.
     */
    engines?: Record<string, () => any>;
    /**
     * Define the engine to use for parsing front-matter.
     *
     * ```ts
     * { language: 'toml' }
     * ```
     */
    language?: string;
    /**
     * Open and close delimiters can be passed in as an array of strings.
     */
    delimiters?: string | [string, string];
}
interface ProcessedFrontmatter {
    /**
     * non-meta props intended for the HEAD of the page
     */
    head: Record<string, any>;
    /**
     * Meta properties intended for the HEAD of the page
     */
    metaProps: MetaProperty[];
    /**
     * The core metadata that a page contains
     */
    frontmatter: Frontmatter;
    /**
     * a dictionary of key/values to that are intended to be associated with the route's
     * metadata.
     */
    routeMeta: RouteProperties;
}
interface Options {
    /** allows adding in Builder's which help to expand functionality of this plugin */
    builders?: (() => BuilderRegistration<any, any>)[];
    /**
     * Explicitly set the Vue version
     *
     * @default auto detected
     */
    vueVersion?: string;
    /**
     * Enable head support, need to install @vueuse/head and register to App in main.js
     *
     * @default false
     */
    headEnabled?: boolean;
    /**
     * The head field in frontmatter used to be used for @vueuse/head
     *
     * When an empty string is passed, it will use the root properties of the frontmatter
     *
     * @default ''
     */
    headField?: string;
    /**
     * Parse for frontmatter
     *
     * @default true
     */
    frontmatter?: boolean;
    /**
     * This property determines how to process "excerpts" and acts as a "smart
     * proxy" to the `excerpt` and `excerpt_separator` properties on the popular
     * graymatter package.
     *
     * When this property is set to `true` it uses looks in the body of page
     * and extracts text up to the first "`---`" separator it finds (after
     * frontmatter).
     *
     * If you'd prefer that it instead looks for some _other_ text as a separator
     * you can state that as a string value (this has the same effect of setting `true` and then changing the Graymatter option of `excerpt_separator`).
     *
     * Finally, if you want full control, you can put in a function and receive
     * a callback with the full contents of the page and you can programatically
     * decide what to make
     *
     * @default false
     */
    excerpt?: boolean | ExcerptFunction | string;
    /**
     * Remove custom SFC block
     *
     * @default ['route', 'i18n']
     */
    customSfcBlocks?: string[];
    /**
     * Custom function to provide defaults to the frontmatter and
     * move certain attributes into the "meta" category.
     *
     * Note: _overriding this will remove built-in functionality setting
     * "meta" properties and the built-in "head" support. Do this only
     * if you know what you're doing._
     */
    frontmatterPreprocess?: (frontmatter: Frontmatter, options: ResolvedOptions) => ProcessedFrontmatter;
    /**
     * Expose frontmatter via expose API
     *
     * @default true
     */
    exposeFrontmatter?: boolean;
    /**
     * Expose excerpt via expose API
     *
     * @default false
     */
    exposeExcerpt?: boolean;
    /**
     * Add `v-pre` to `<code>` tag to escape curly brackets interpolation
     *
     * @see https://github.com/antfu/vite-plugin-md/issues/14
     * @default true
     */
    escapeCodeTagInterpolation?: boolean;
    /**
     * Options passed to Markdown It
     *
     * @default { html: true, linkify: true, typographer: true }
     */
    markdownItOptions?: MarkdownIt.Options;
    /**
     * Plugins for Markdown It
     */
    markdownItUses?: (MarkdownIt.PluginSimple | [MarkdownIt.PluginSimple | MarkdownIt.PluginWithOptions<any>, any] | any)[];
    /**
     * A function providing the Markdown It instance gets the ability to apply custom
     * settings/plugins
     */
    markdownItSetup?: (MarkdownIt: MarkdownIt) => void;
    /**
     * Options passed to [gray-matter](https://github.com/jonschlinkert/gray-matter#options)
     */
    grayMatterOptions?: GraymatterOptions;
    /**
     * Class names for wrapper div
     *
     * @default 'markdown-body'
     */
    wrapperClasses?: string | string[];
    /**
     * Component name to wrapper with
     *
     * @default undefined
     */
    wrapperComponent?: string | undefined | null;
    /**
     * Custom tranformations to apply _before_ and/or _after_ the markdown transformation
     *
     * Note: these transforms provide _raw_ inputs which means that "code" represents
     * markdown content along with possibly frontmatter (in the before state) and all of
     * of the SFC blocks (e.g., template, script, custom) in string format.
     */
    transforms?: {
        before?: (code: string, id: string) => string;
        after?: (code: string, id: string) => string;
    };
    /**
     * Optionally allows user to explicitly whitelist files which will be transformed
     * from markdown to VueJS components. By default all files with `.md` extension
     * are included.
     */
    include?: FilterPattern;
    /**
     * Allows user to add a blacklist filter to exclude transforming some of the markdown
     * files to VueJS components.
     */
    exclude?: FilterPattern;
}
interface ResolvedOptions extends Required<Options> {
    wrapperClasses: string;
}

declare type WithTagAndBase<T extends LinkElement> = T & {
    tagName?: string;
    _base: string;
};

/**
 * A callback function which is passed a name/value dictionary of
 * properties on a link tag and expects these inputs to be converted
 * to a similarly structured response before the Markdown is rendered
 * to HTML.
 */
declare type LinkTransformer = (link: WithTagAndBase<LinkElement>) => WithTagAndBase<LinkElement>;
/**
 * a callback function which is provided a Link's key/value
 * pairs as context and expects a string based response
 */
declare type StringTransformer = (meta: LinkElement) => string;
interface LinkifyConfig {
    /**
     * The relative path to the root of your markdown content; if you're using
     * the `vite-plugin-pages` plugin this would typically be "src/pages" but is
     * configurable.
     *
     * @default "src/pages"
     */
    rootDir: string;
    /**
     * the class to add to links which are external to the hosting site
     *
     * @default "external-link"
     */
    externalLinkClass: undefined | string | StringTransformer;
    /**
     * the class to add to links which are the same as the hosting site
     *
     * @default "internal-link"
     */
    internalLinkClass: undefined | string | StringTransformer;
    /**
     * the class to add to links which internal and _relative_ to the current route
     *
     * @default undefined
     */
    relativeLinkClass: undefined | string | StringTransformer;
    /**
   * the class to add to links which are internal but _fully qualified_ (aka, not relative)
   *
   * @default undefined
   */
    fullyQualifiedLinkClass: undefined | string | StringTransformer;
    /**
   * the class to add to links which using VueJS router to navigate
   *
   * @default "router-link"
   */
    routerLinkClass: undefined | string | StringTransformer;
    /**
     * the class to add to links are an anchor link to somewhere on
     * the same page (e.g., links starting as `#something`)
     *
     * @default "anchor-tag"
     */
    anchorTagClass: undefined | string | StringTransformer;
    /**
     * the class to add to _external_ links which refer to an "http"
     * (aka, non-TLS) base resource.
     *
     * @default "insecure"
     */
    insecureClass: undefined | string | StringTransformer;
    /**
     * the class to add to _external_ links which uses a "file" instead
     * of "https" protocol reference.
     *
     * @default "file-link"
     */
    fileClass: undefined | string | StringTransformer;
    /**
     * the class to add to _external_ links which refers to a
     * "mailto:" based URI resource.
     *
     * @default "mailto-link"
     */
    mailtoClass: undefined | string | StringTransformer;
    /**
     * the class to add to any link which points to an image directly
     *
     * @default "image-reference"
     */
    imageClass: undefined | string | StringTransformer;
    /**
     * the class to add to any link which points to a known document
     * type (e.g., `.doc`, `.txt`, `.xls`, `.pdf`, etc.).
     *
     * @default "doc-reference"
     */
    documentClass: undefined | string | StringTransformer;
    /**
     * a tuple which defines both a RegEx rule/pattern and a resultant **class** string which
     * is applied if the rule tests positive
     */
    ruleBasedClasses: [rule: RegExp, klass: string][];
    /**
     * allows you to specify what `target` property external links
     * will be openned up in.
     *
     * @default "_blank"
     */
    externalTarget: undefined | string | StringTransformer;
    /**
     * the `rel` property for external links
     *
     * @default "noreferrer noopenner"
     */
    externalRel: undefined | string | StringTransformer;
    /**
     * allows you to specify what `target` property external links
     * will be openned up in.
     *
     * @default undefined
     */
    internalTarget: undefined | string | StringTransformer;
    /**
     * the `rel` property for internal links
     *
     * @default undefined
     */
    internalRel: undefined | string | StringTransformer;
    /**
     * if set to **true**, all internal `<a>` link tags will be converted to
     * `<router-link>` tags instead (and "href" converted to the "to" prop).
     * This plugin will also attempt to locate the containing app's import of
     * **vue-router** so that it may resolve relative paths.
     *
     * Alternatively you can pass in the `Router` API or if you have an alternative
     * router you can pass in a `Ref<string>` or `ComputedRef<string>` and it will
     * be evaluated at FINISH
     *
     * @default true
     */
    useRouterLinks: boolean;
    /**
     * Allows for automatic removal of `index.md` and `index.html` in URL links
     * in favor of just using the route path for.
     *
     * Note: internal links only.
     *
     * @default true
     */
    cleanIndexRoutes: boolean;
    /**
     * Allows for automatic removal of all file extensions found in internal
     * links with the assumption that the filename represents the last part
     * of the path.
     *
     * @default true
     */
    cleanAllRoutes: boolean;
    /**
     * If you still want to modify these tags after all that's already happened,
     * feel free to hook into a callback where you will be given the results
     * to modify to your heart's content.
     *
     * @default undefined
     */
    postProcessing: LinkTransformer;
}

/**
 * A _builder_ which provides:
 * - contextual classes to links within Markdown pages
 *    - relative versus absolute links
 *    - local versus external links
 *    - content-type based links
 *    - protocol based links (http/file/mailto)
 * - cleans up _relative_ links relative nature based
 * on current route
 * - converts `<a href>` properties to `<router-link to>` props
 * - `postProcessing` hook to allow programatic mutation
 * beyond the core use-cases
 */
declare const link: BuilderApi<Partial<LinkifyConfig>, "parser">;

declare type HeadProperties = 'title' | 'link' | 'base' | 'style' | 'script' | 'htmlAttrs' | 'bodyAttrs';
declare type DefaultValueCallback = (fm: Frontmatter) => any;
interface MetaConfig {
    /**
     * Properties which found in frontmatter will be transformed to "meta" properties in HEAD
     */
    metaProps: string[];
    routeProps: string[];
    headProps: HeadProperties[];
    /** default values for a property if none was stated */
    defaults: Record<string, any | DefaultValueCallback>;
}
declare const meta: BuilderApi<Partial<MetaConfig>, "metaExtracted">;

declare function VitePluginMarkdown(userOptions?: Options): Plugin;

export { VitePluginMarkdown as default, link, meta };
